{# Partial: ATS Kanban Pipeline Board #}
{# Context: job_id, pipeline (dict stage_key -> {label, entries}), stages, stage_labels, PipelineStage #}

<div id="pipeline-board"
     x-data="{ dragging: false, dragEntryId: null }"
     hx-get="/ats/stellen/{{ job_id }}/pipeline"
     hx-trigger="pipeline-updated from:body"
     hx-swap="outerHTML">

    {# ── Kanban Columns (horizontal scroll) ───────────────── #}
    <div class="flex gap-4 overflow-x-auto pb-4 min-h-[400px]" style="scrollbar-width: thin;">

        {% for stage in stages %}
        {% set stage_key = stage.value %}
        {% set stage_data = pipeline.get(stage_key, {'label': stage_labels[stage], 'entries': []}) %}
        {% set entries = stage_data.entries %}

        <div class="flex-shrink-0 w-72">
            {# Column Header #}
            <div class="flex items-center justify-between mb-3 px-1">
                <div class="flex items-center gap-2">
                    {# Stage color indicator #}
                    {% set stage_colors = {
                        'matched': 'bg-blue-500',
                        'sent': 'bg-indigo-500',
                        'feedback': 'bg-amber-500',
                        'interview_1': 'bg-purple-500',
                        'interview_2': 'bg-purple-500',
                        'interview_3': 'bg-purple-500',
                        'offer': 'bg-emerald-500',
                        'placed': 'bg-green-500'
                    } %}
                    <div class="w-2.5 h-2.5 rounded-full {{ stage_colors.get(stage_key, 'bg-gray-400') }}"></div>
                    <h3 class="text-sm font-semibold text-gray-700">{{ stage_data.label }}</h3>
                </div>
                <span class="inline-flex items-center justify-center w-6 h-6 rounded-full bg-gray-100 text-xs font-medium text-gray-600">
                    {{ entries | length }}
                </span>
            </div>

            {# Column Body (droppable) #}
            <div class="bg-gray-50 rounded-xl border border-gray-200 p-2 min-h-[320px] pipeline-column"
                 data-stage="{{ stage_key }}"
                 id="column-{{ stage_key }}">

                {% if entries | length > 0 %}
                <div class="space-y-2">
                    {% for entry in entries %}
                        {% include 'partials/ats_pipeline_card.html' %}
                    {% endfor %}
                </div>
                {% else %}
                <div class="flex items-center justify-center h-32 text-gray-400">
                    <p class="text-xs">Keine Kandidaten</p>
                </div>
                {% endif %}
            </div>
        </div>
        {% endfor %}
    </div>

    {# ── Rejected Section (collapsed) ─────────────────────── #}
    {% set rejected_data = pipeline.get('rejected', {'label': 'Abgelehnt', 'entries': []}) %}
    {% set rejected_entries = rejected_data.entries %}

    <div x-data="{ open: false }" class="mt-6 border-t border-gray-200 pt-4">
        <button @click="open = !open"
                type="button"
                class="w-full flex items-center justify-between px-4 py-3 bg-red-50 hover:bg-red-100 rounded-xl transition-colors">
            <div class="flex items-center gap-2">
                <div class="w-2.5 h-2.5 rounded-full bg-red-500"></div>
                <span class="text-sm font-semibold text-red-700">Abgelehnt</span>
                <span class="inline-flex items-center justify-center w-6 h-6 rounded-full bg-red-100 text-xs font-medium text-red-600">
                    {{ rejected_entries | length }}
                </span>
            </div>
            <svg :class="{ 'rotate-180': open }"
                 class="h-5 w-5 text-red-400 transition-transform duration-200"
                 fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
            </svg>
        </button>

        <div x-show="open"
             x-transition:enter="transition ease-out duration-200"
             x-transition:enter-start="opacity-0 -translate-y-2"
             x-transition:enter-end="opacity-100 translate-y-0"
             x-cloak
             class="mt-3 pipeline-column bg-red-50/50 rounded-xl border border-red-200 p-2"
             data-stage="rejected"
             id="column-rejected">

            {% if rejected_entries | length > 0 %}
            <div class="space-y-2">
                {% for entry in rejected_entries %}
                    {% include 'partials/ats_pipeline_card.html' %}
                {% endfor %}
            </div>
            {% else %}
            <div class="flex items-center justify-center h-16 text-gray-400">
                <p class="text-xs">Keine abgelehnten Kandidaten</p>
            </div>
            {% endif %}
        </div>
    </div>
</div>

{# ── SortableJS Integration ──────────────────────────────── #}
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script>
(function() {
    function initPipelineSortable() {
        const columns = document.querySelectorAll('.pipeline-column');
        const jobId = '{{ job_id }}';

        columns.forEach(function(column) {
            new Sortable(column.querySelector('.space-y-2') || column, {
                group: 'pipeline',
                animation: 150,
                ghostClass: 'opacity-30',
                chosenClass: 'ring-2 ring-primary-400',
                dragClass: 'shadow-lg',
                handle: '.drag-handle',
                draggable: '.pipeline-card',

                onEnd: function(evt) {
                    const entryId = evt.item.dataset.entryId;
                    const newStage = evt.to.closest('.pipeline-column').dataset.stage;

                    if (!entryId || !newStage) return;

                    // PATCH stage via API
                    fetch('/api/ats/pipeline/entries/' + entryId + '/stage', {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ stage: newStage }),
                    })
                    .then(function(response) {
                        if (!response.ok) throw new Error('Stage update failed');
                        return response.json();
                    })
                    .then(function() {
                        // Reload pipeline board via HTMX
                        document.body.dispatchEvent(new CustomEvent('pipeline-updated'));
                    })
                    .catch(function(error) {
                        console.error('Pipeline update error:', error);
                        // Reload to revert on error
                        document.body.dispatchEvent(new CustomEvent('pipeline-updated'));
                    });
                }
            });
        });
    }

    // Initialize after DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initPipelineSortable);
    } else {
        initPipelineSortable();
    }

    // Re-initialize after HTMX swaps
    document.addEventListener('htmx:afterSwap', function(evt) {
        if (evt.detail.target && evt.detail.target.id === 'pipeline-board') {
            setTimeout(initPipelineSortable, 50);
        }
    });
})();
</script>
